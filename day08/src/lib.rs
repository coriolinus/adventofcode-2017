pub mod parser; // generated by lalrpop
pub use parser::parse_instruction;

use std::collections::HashMap;

pub type Register = i64;
// Can't use references as keys, apparently:
// https://stackoverflow.com/a/32403439/504550
// Unfortunately, this means that we have to create a String
// every time we want to check a value. Oh well.
pub type Registers = HashMap<String, Register>;
pub type Program<'a> = Vec<Instruction<'a>>;

#[derive(Debug, PartialEq, Eq)]
pub enum Operation {
    Inc,
    Dec,
}

#[derive(Debug, PartialEq, Eq)]
pub enum Comparison {
    Gt,
    Lt,
    Gte,
    Lte,
    Eq,
    Ne,
}

#[derive(Debug, PartialEq, Eq)]
pub struct Instruction<'a> {
    register: &'a str,
    operation: Operation,
    qty: Register,
    compare_register: &'a str,
    comparison: Comparison,
    compare_qty: Register,
}

impl<'a> Instruction<'a> {
    pub fn new(
        register: &'a str,
        operation: Operation,
        qty: Register,
        compare_register: &'a str,
        comparison: Comparison,
        compare_qty: Register,
    ) -> Instruction<'a> {
        Instruction {
            register: register,
            operation: operation,
            qty: qty,
            compare_register: compare_register,
            comparison: comparison,
            compare_qty: compare_qty,
        }
    }

    /// apply the comparison in this instruction
    fn compare(&self, registers: &mut Registers) -> bool {
        use Comparison::*;
        match self.comparison {
            Gt => {
                *registers
                    .entry(self.compare_register.to_string())
                    .or_insert(0) > self.compare_qty
            }
            Lt => {
                *registers
                    .entry(self.compare_register.to_string())
                    .or_insert(0) < self.compare_qty
            }
            Gte => {
                *registers
                    .entry(self.compare_register.to_string())
                    .or_insert(0) >= self.compare_qty
            }
            Lte => {
                *registers
                    .entry(self.compare_register.to_string())
                    .or_insert(0) <= self.compare_qty
            }
            Eq => {
                *registers
                    .entry(self.compare_register.to_string())
                    .or_insert(0) == self.compare_qty
            }
            Ne => {
                *registers
                    .entry(self.compare_register.to_string())
                    .or_insert(0) != self.compare_qty
            }
        }
    }

    /// Apply this operation to its register
    fn apply(&self, registers: &mut Registers) {
        use Operation::*;
        match self.operation {
            Inc => *registers.entry(self.register.to_string()).or_insert(0) += self.qty,
            Dec => *registers.entry(self.register.to_string()).or_insert(0) -= self.qty,
        }
    }

    pub fn process(&self, registers: &mut Registers) {
        if self.compare(registers) {
            self.apply(registers);
        }
    }
}

pub fn parse<'a>(input: &'a str) -> Program<'a> {
    input
        .lines()
        .filter(|line| !line.trim().is_empty())
        .map(|line| {
            parse_instruction(line).expect("All input lines should parse correctly")
        })
        .collect()
}

pub fn execute<'a>(program: &Program<'a>) -> Registers {
    let mut registers = Registers::new();
    for instruction in program {
        instruction.process(&mut registers);
    }
    registers
}

pub fn max_value_in(registers: &Registers) -> Option<Register> {
    registers.values().max().map(|&r| r)
}

pub fn execute_collecting_max<'a>(program: &Program<'a>) -> Option<Register> {
    let mut registers = Registers::new();
    let mut max_value = None;
    for instruction in program {
        instruction.process(&mut registers);
        max_value = match (max_value, max_value_in(&registers)) {
            (None, m) => m,
            (Some(p), Some(c)) if c > p => Some(c),
            (c, _) => c,
        };
    }
    max_value
}
